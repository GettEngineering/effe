{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Effe library Motivation The Effe helps us to write process flows at Gett with the following features: Provide visibility and traceability into these process flows Errors are wrapped automatically Dependencies are built for flow automatically Easy flow debugging Easy flow extending Split dependencies for steps in flow: the step has only dependencies that it needs Allow greater reuse of existing functions Easy flow testing: small interface/easier to understanding what happening","title":"Introduction"},{"location":"#effe-library","text":"","title":"Effe library"},{"location":"#motivation","text":"The Effe helps us to write process flows at Gett with the following features: Provide visibility and traceability into these process flows Errors are wrapped automatically Dependencies are built for flow automatically Easy flow debugging Easy flow extending Split dependencies for steps in flow: the step has only dependencies that it needs Allow greater reuse of existing functions Easy flow testing: small interface/easier to understanding what happening","title":"Motivation"},{"location":"API/","text":"effe import github.com/GettEngineering/effe Package effe contains directives for Effe code generation. For an overview of working with Effe\\, see the user guide at https://github.com/GettEngineering/effe/blob/master/docs/docs/GettingStarted.md The directives in this package are used as input to the Effe code generation tool. The entry point of Effe's analysis are injector functions: function templates denoted by only containing a call to BuildFlow. The arguments to BuildFlow describes a set of steps and the Effe code generation tool builds calls of steps according to strategy. Index func BuildFlow(funcs ...StepFunc) interface{} type CaseKey type StepFunc func Before(fn interface{}) StepFunc func Case(key CaseKey, funcs ...StepFunc) StepFunc func Decision(tag interface{}, cases ...StepFunc) StepFunc func Failure(fn interface{}) StepFunc func Step(fn interface{}) StepFunc func Success(fn interface{}) StepFunc func Wrap(beforeFunc StepFunc, afterFunc StepFunc, steps ...StepFunc) StepFunc func BuildFlow func BuildFlow ( funcs ... StepFunc ) interface {} Build is placed in the body of an inhector function template to declare the steps. type CaseKey Type for declaring business logic for specific case type CaseKey interface {} type StepFunc Based type for declaring steps type StepFunc interface {} func Before func Before ( fn interface {}) StepFunc This directive helps to declare a function which executes before other steps in a directive Wrap. This directive can be used only in Wrap. func Case func Case ( key CaseKey , funcs ... StepFunc ) StepFunc This directive can be used only in Decision. Case declares the steps which will execute. func Decision func Decision ( tag interface {}, cases ... StepFunc ) StepFunc Decision directive helps to organize branching of our business logic. First argument can be a type or a field from the type. Golang doesn't provide an opportunity to pass types to function argument. For that you need to create an empty object with your type. If you want branching your logic by field from type you can declare it. For that you need to create an empty object with your type and get field from it. Other arguments declare handlers for every case. Every case can be declared with Case directive. Failure directive works here too. With Failure you can declare an error handler for case. Examples: func BuildMyBusinessFlow(){ effe.BuildFlow( effe.Step(tryLock), effe.Decision(new(Lock), effe.Case(true, effe.Step(step1)), effe.Case(false, effe.Step(step2)), ), ) } func BuildMyBusinessFlow2(){ effe.BuildFlow( effe.Step(tryLock), effe.Decision(Locker{}.Lock, effe.Case(true, effe.Step(step1)), effe.Case(false, effe.Step(step2)), ), ) } func Failure func Failure ( fn interface {}) StepFunc A Failure works the same way as Step\\, but with one exception: a function executes only if one of steps returns an error. func Step func Step ( fn interface {}) StepFunc A Step declares a function which will be executed in this place. The function should have the following format: Format: func step1(dep1 FirstDependency, dep2 SecondDependency) func(req *httpRequest) error { return func(req *httpRequest) error { return dep1.Send(dep2, req) } } Function arguments should be dependencies for your step. It is necessary to separate dependencies between steps. You don't need to create big service objects. Effe code generation tool calculates all dependencies for your flow and Effe generates a service object with dependecies automatically. Function return value should be the function which executes here. Also\\, you can call another business flow here. It helps to split and reuse existing business logic. Examples: func BuildMyFirstBusinessFlow(){ effe.BuldFlow( effe.Step(step1), ) } func BuildMySecondBusinessFlow(){ effe.BuildFlow( effe.Step(BuildMyFirstBusinessFlow), ) } func Success func Success ( fn interface {}) StepFunc This directive helps to declare a function which executes after other steps in a directive Wrap and if not one step returned an error. This directive can be used only in Wrap. func Wrap func Wrap ( beforeFunc StepFunc , afterFunc StepFunc , steps ... StepFunc ) StepFunc Wrap helps to declare a block of steps which is executed in the following sequence. If we declare a function with Before directive\\, then it will be executed first. After that\\, all functions declared with Step directive will be executed. Lastly a function declared with Success directive will be executed. Also\\, we can declare an error handler here with Failure directive. Examples: func BuildMyBusinessFlow() { effe.BuildFlow( effe.Step(step1), effe.Step(step2), effe.Wrap(effe.Before(lock), effe.Success(unlock), effe.Failure(catchErrAndUnlock), effe.Step(step3), effe.Step(step4), ), ) } Generated by gomarkdoc","title":"Api"},{"location":"API/#effe","text":"import github.com/GettEngineering/effe Package effe contains directives for Effe code generation. For an overview of working with Effe\\, see the user guide at https://github.com/GettEngineering/effe/blob/master/docs/docs/GettingStarted.md The directives in this package are used as input to the Effe code generation tool. The entry point of Effe's analysis are injector functions: function templates denoted by only containing a call to BuildFlow. The arguments to BuildFlow describes a set of steps and the Effe code generation tool builds calls of steps according to strategy.","title":"effe"},{"location":"API/#index","text":"func BuildFlow(funcs ...StepFunc) interface{} type CaseKey type StepFunc func Before(fn interface{}) StepFunc func Case(key CaseKey, funcs ...StepFunc) StepFunc func Decision(tag interface{}, cases ...StepFunc) StepFunc func Failure(fn interface{}) StepFunc func Step(fn interface{}) StepFunc func Success(fn interface{}) StepFunc func Wrap(beforeFunc StepFunc, afterFunc StepFunc, steps ...StepFunc) StepFunc","title":"Index"},{"location":"API/#func-buildflow","text":"func BuildFlow ( funcs ... StepFunc ) interface {} Build is placed in the body of an inhector function template to declare the steps.","title":"func BuildFlow"},{"location":"API/#type-casekey","text":"Type for declaring business logic for specific case type CaseKey interface {}","title":"type CaseKey"},{"location":"API/#type-stepfunc","text":"Based type for declaring steps type StepFunc interface {}","title":"type StepFunc"},{"location":"API/#func-before","text":"func Before ( fn interface {}) StepFunc This directive helps to declare a function which executes before other steps in a directive Wrap. This directive can be used only in Wrap.","title":"func Before"},{"location":"API/#func-case","text":"func Case ( key CaseKey , funcs ... StepFunc ) StepFunc This directive can be used only in Decision. Case declares the steps which will execute.","title":"func Case"},{"location":"API/#func-decision","text":"func Decision ( tag interface {}, cases ... StepFunc ) StepFunc Decision directive helps to organize branching of our business logic. First argument can be a type or a field from the type. Golang doesn't provide an opportunity to pass types to function argument. For that you need to create an empty object with your type. If you want branching your logic by field from type you can declare it. For that you need to create an empty object with your type and get field from it. Other arguments declare handlers for every case. Every case can be declared with Case directive. Failure directive works here too. With Failure you can declare an error handler for case. Examples: func BuildMyBusinessFlow(){ effe.BuildFlow( effe.Step(tryLock), effe.Decision(new(Lock), effe.Case(true, effe.Step(step1)), effe.Case(false, effe.Step(step2)), ), ) } func BuildMyBusinessFlow2(){ effe.BuildFlow( effe.Step(tryLock), effe.Decision(Locker{}.Lock, effe.Case(true, effe.Step(step1)), effe.Case(false, effe.Step(step2)), ), ) }","title":"func Decision"},{"location":"API/#func-failure","text":"func Failure ( fn interface {}) StepFunc A Failure works the same way as Step\\, but with one exception: a function executes only if one of steps returns an error.","title":"func Failure"},{"location":"API/#func-step","text":"func Step ( fn interface {}) StepFunc A Step declares a function which will be executed in this place. The function should have the following format: Format: func step1(dep1 FirstDependency, dep2 SecondDependency) func(req *httpRequest) error { return func(req *httpRequest) error { return dep1.Send(dep2, req) } } Function arguments should be dependencies for your step. It is necessary to separate dependencies between steps. You don't need to create big service objects. Effe code generation tool calculates all dependencies for your flow and Effe generates a service object with dependecies automatically. Function return value should be the function which executes here. Also\\, you can call another business flow here. It helps to split and reuse existing business logic. Examples: func BuildMyFirstBusinessFlow(){ effe.BuldFlow( effe.Step(step1), ) } func BuildMySecondBusinessFlow(){ effe.BuildFlow( effe.Step(BuildMyFirstBusinessFlow), ) }","title":"func Step"},{"location":"API/#func-success","text":"func Success ( fn interface {}) StepFunc This directive helps to declare a function which executes after other steps in a directive Wrap and if not one step returned an error. This directive can be used only in Wrap.","title":"func Success"},{"location":"API/#func-wrap","text":"func Wrap ( beforeFunc StepFunc , afterFunc StepFunc , steps ... StepFunc ) StepFunc Wrap helps to declare a block of steps which is executed in the following sequence. If we declare a function with Before directive\\, then it will be executed first. After that\\, all functions declared with Step directive will be executed. Lastly a function declared with Success directive will be executed. Also\\, we can declare an error handler here with Failure directive. Examples: func BuildMyBusinessFlow() { effe.BuildFlow( effe.Step(step1), effe.Step(step2), effe.Wrap(effe.Before(lock), effe.Success(unlock), effe.Failure(catchErrAndUnlock), effe.Step(step3), effe.Step(step4), ), ) } Generated by gomarkdoc","title":"func Wrap"},{"location":"GettingStarted/","text":"Getting Started Install go get github.com/GettEngineering/effe/cmd/effe Create new project mkdir example cd example go mod init github.com/example/example Create repositories/structs repositories.go package mypackage import ( context ) type UserRepository interface { Create ( context . Context , User ) error } structs.go package mypackage type User struct { Email string Password string } type UserAttributes struct { Email string Password string } Create steps steps.go package mypackage import ( context ) func buildUser () func ( UserAttributes ) User { return func ( uAttrs UserAttributes ) User { return User { Email : uAttrs . Email , Password : uAttrs . Password , } } } func createUser ( userRepo UserRepository ) func ( context . Context , User ) error { return func ( ctx context . Context , user User ) error { return userRepo . Create ( ctx , user ) } } Define Workflow effe.go // +build effeinject package mypackage import ( github.com/GettEngineering/effe ) func BuildCreateUserFlow ( uAttrs UserAttributes ) error { effe . BuildFlow ( effe . Step ( buildUser ), effe . Step ( createUser ), ) return nil } Generate flow run effe command $ effe effe: wrote /app/effe_gen.go effe_gen.go // Code generated by Effe. DO NOT EDIT. //+build !effeinject package mypackage import ( context fmt github.com/example/example ) func BuildCreateUserFlow ( service BuildCreateUserFlowService ) BuildCreateUserFlowFunc { return func ( ctx context . Context , UserAttributesVal UserAttributes ) error { UserVal := service . BuildUser ( UserAttributesVal ) err := service . CreateUser ( ctx , UserVal ) if err != nil { return err } return nil } } func NewBuildCreateUserFlowImpl ( userRepo UserRepository ) * BuildCreateUserFlowImpl { return BuildCreateUserFlowImpl { buildUserFieldFunc : buildUser (), createUserFieldFunc : createUser ( userRepo )} } type BuildCreateUserFlowService interface { BuildUser ( uAttrs UserAttributes ) User CreateUser ( ctx context . Context , user User ) error } type BuildCreateUserFlowImpl struct { buildUserFieldFunc func ( uAttrs UserAttributes ) User createUserFieldFunc func ( ctx context . Context , user User ) error } type BuildCreateUserFlowFunc func ( ctx context . Context , UserAttributesVal UserAttributes ) error func ( b * BuildCreateUserFlowImpl ) BuildUser ( uAttrs UserAttributes ) User { return b . buildUserFieldFunc ( uAttrs ) } func ( b * BuildCreateUserFlowImpl ) CreateUser ( ctx context . Context , user User ) error { return b . createUserFieldFunc ( ctx , user ) }","title":"Getting Started"},{"location":"GettingStarted/#getting-started","text":"","title":"Getting Started"},{"location":"GettingStarted/#install","text":"go get github.com/GettEngineering/effe/cmd/effe","title":"Install"},{"location":"GettingStarted/#create-new-project","text":"mkdir example cd example go mod init github.com/example/example","title":"Create new project"},{"location":"GettingStarted/#create-repositoriesstructs","text":"","title":"Create repositories/structs"},{"location":"GettingStarted/#repositoriesgo","text":"package mypackage import ( context ) type UserRepository interface { Create ( context . Context , User ) error }","title":"repositories.go"},{"location":"GettingStarted/#structsgo","text":"package mypackage type User struct { Email string Password string } type UserAttributes struct { Email string Password string }","title":"structs.go"},{"location":"GettingStarted/#create-steps","text":"","title":"Create steps"},{"location":"GettingStarted/#stepsgo","text":"package mypackage import ( context ) func buildUser () func ( UserAttributes ) User { return func ( uAttrs UserAttributes ) User { return User { Email : uAttrs . Email , Password : uAttrs . Password , } } } func createUser ( userRepo UserRepository ) func ( context . Context , User ) error { return func ( ctx context . Context , user User ) error { return userRepo . Create ( ctx , user ) } }","title":"steps.go"},{"location":"GettingStarted/#define-workflow","text":"","title":"Define Workflow"},{"location":"GettingStarted/#effego","text":"// +build effeinject package mypackage import ( github.com/GettEngineering/effe ) func BuildCreateUserFlow ( uAttrs UserAttributes ) error { effe . BuildFlow ( effe . Step ( buildUser ), effe . Step ( createUser ), ) return nil }","title":"effe.go"},{"location":"GettingStarted/#generate-flow","text":"run effe command $ effe effe: wrote /app/effe_gen.go","title":"Generate flow"},{"location":"GettingStarted/#effe_gengo","text":"// Code generated by Effe. DO NOT EDIT. //+build !effeinject package mypackage import ( context fmt github.com/example/example ) func BuildCreateUserFlow ( service BuildCreateUserFlowService ) BuildCreateUserFlowFunc { return func ( ctx context . Context , UserAttributesVal UserAttributes ) error { UserVal := service . BuildUser ( UserAttributesVal ) err := service . CreateUser ( ctx , UserVal ) if err != nil { return err } return nil } } func NewBuildCreateUserFlowImpl ( userRepo UserRepository ) * BuildCreateUserFlowImpl { return BuildCreateUserFlowImpl { buildUserFieldFunc : buildUser (), createUserFieldFunc : createUser ( userRepo )} } type BuildCreateUserFlowService interface { BuildUser ( uAttrs UserAttributes ) User CreateUser ( ctx context . Context , user User ) error } type BuildCreateUserFlowImpl struct { buildUserFieldFunc func ( uAttrs UserAttributes ) User createUserFieldFunc func ( ctx context . Context , user User ) error } type BuildCreateUserFlowFunc func ( ctx context . Context , UserAttributesVal UserAttributes ) error func ( b * BuildCreateUserFlowImpl ) BuildUser ( uAttrs UserAttributes ) User { return b . buildUserFieldFunc ( uAttrs ) } func ( b * BuildCreateUserFlowImpl ) CreateUser ( ctx context . Context , user User ) error { return b . createUserFieldFunc ( ctx , user ) }","title":"effe_gen.go"},{"location":"architecture/","text":"High level architecture Effe contains from the following components: Generator This component is responsible for connecting and run all components. Loaders When Generator finds a function which contains another function - BuildFlow it's a trigger to run Loader for package loaders and converts Golang Ast to a tree of components. Strategies This component converts a tree of components to Golang code. Drawer This component convers a tree of components to diagrams.","title":"Architecture"},{"location":"architecture/#high-level-architecture","text":"Effe contains from the following components: Generator This component is responsible for connecting and run all components. Loaders When Generator finds a function which contains another function - BuildFlow it's a trigger to run Loader for package loaders and converts Golang Ast to a tree of components. Strategies This component converts a tree of components to Golang code. Drawer This component convers a tree of components to diagrams.","title":"High level architecture"},{"location":"chain/","text":"Chain strategy It's the default stratagy for Effe. This strategy converts a tree of components to a sequence of calling functions one by one. Example: effe.BuildFlow( effe.Step(step1), effe.Step(step2), effe.Step(step3), effe.Step(step4), ) Result: return func() (b, error) { val1, err := service.Step1() if err != nil { return nil, err } val2 := err = service.Step2(val1) if err != nil { return nil, err } return nil val2, err := service.Step3(val2) if err != nil { return nil, err } val2, err = service.Step4(val2) if err != nil { return nil, err } return val2, nil }","title":"Default strategy"},{"location":"chain/#chain-strategy","text":"It's the default stratagy for Effe. This strategy converts a tree of components to a sequence of calling functions one by one. Example: effe.BuildFlow( effe.Step(step1), effe.Step(step2), effe.Step(step3), effe.Step(step4), ) Result: return func() (b, error) { val1, err := service.Step1() if err != nil { return nil, err } val2 := err = service.Step2(val1) if err != nil { return nil, err } return nil val2, err := service.Step3(val2) if err != nil { return nil, err } val2, err = service.Step4(val2) if err != nil { return nil, err } return val2, nil }","title":"Chain strategy"},{"location":"customization/","text":"Customization You can define custom tasks for Effe. We want to generate for making a post request by url. effe.BuildFlow( effe.Step(step1), mytask.POST( http://example.com , ), ) For that, you should create the function POST in your package mytask. package mytask func POST(uri string) interface{} { panic( implementation is not generated, run myeffe ) } Write functions for: Loader Strategy Drawer // Loading and validating expressions. func LoadPostRequestComponent(effeConditionCall *ast.CallExpr, f loaders.FlowLoader) (types.Component, error) { return nil, nil // type of your component and error } // Generates code. func GenPostRequestComponent(f strategies.FlowGen, c types.Component) (strategies.ComponentCall, error) { return nil, nil } // Generates a statement for plantuml. func DrawPostRequestComponent(drawer.Drawer, types.Component) (drawer.ComponentStmt, error) { return nil, nil } and register it settings := generator.DefaultSettigs() strategy := strategies.NewChain(strategies.WithServiceObjectName(settings.LocalInterfaceVarname())) err := strategy.Register( POST , testcustomization.GenPostRequestComponent) if err != nil { fmt.Println(err) os.Exit(1) } loader := loaders.NewLoader(loaders.WithPackages([]string{ effe , testcustomization })) err = loader.Register( POST , testcustomization.LoadPostRequestComponent) if err != nil { fmt.Println(err) os.Exit(1) } d := drawer.NewDrawer() err = d.Register( POST , DrawPostRequestComponent) if err != nil { fmt.Println(err) os.Exit(1) } gen := generator.NewGenerator( generator.WithSetttings(settings), generator.WithLoader(loader), generator.WithStrategy(strategy), generator.WithDrawer(d), ) // Run generator gen.Generate(context.Background(), d, os.Environ(), []string{ . }","title":"Customization"},{"location":"customization/#customization","text":"You can define custom tasks for Effe. We want to generate for making a post request by url. effe.BuildFlow( effe.Step(step1), mytask.POST( http://example.com , ), ) For that, you should create the function POST in your package mytask. package mytask func POST(uri string) interface{} { panic( implementation is not generated, run myeffe ) } Write functions for: Loader Strategy Drawer // Loading and validating expressions. func LoadPostRequestComponent(effeConditionCall *ast.CallExpr, f loaders.FlowLoader) (types.Component, error) { return nil, nil // type of your component and error } // Generates code. func GenPostRequestComponent(f strategies.FlowGen, c types.Component) (strategies.ComponentCall, error) { return nil, nil } // Generates a statement for plantuml. func DrawPostRequestComponent(drawer.Drawer, types.Component) (drawer.ComponentStmt, error) { return nil, nil } and register it settings := generator.DefaultSettigs() strategy := strategies.NewChain(strategies.WithServiceObjectName(settings.LocalInterfaceVarname())) err := strategy.Register( POST , testcustomization.GenPostRequestComponent) if err != nil { fmt.Println(err) os.Exit(1) } loader := loaders.NewLoader(loaders.WithPackages([]string{ effe , testcustomization })) err = loader.Register( POST , testcustomization.LoadPostRequestComponent) if err != nil { fmt.Println(err) os.Exit(1) } d := drawer.NewDrawer() err = d.Register( POST , DrawPostRequestComponent) if err != nil { fmt.Println(err) os.Exit(1) } gen := generator.NewGenerator( generator.WithSetttings(settings), generator.WithLoader(loader), generator.WithStrategy(strategy), generator.WithDrawer(d), ) // Run generator gen.Generate(context.Background(), d, os.Environ(), []string{ . }","title":"Customization"},{"location":"diagrams/","text":"Diagrams If you are run effe with flag -d - Effe generates diagrams in plantuml. You can convert plantuml file to png. Examples;","title":"Diagrams"},{"location":"diagrams/#diagrams","text":"If you are run effe with flag -d - Effe generates diagrams in plantuml. You can convert plantuml file to png. Examples;","title":"Diagrams"}]}