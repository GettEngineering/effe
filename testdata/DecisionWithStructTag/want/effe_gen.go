// Code generated by Effe. DO NOT EDIT.

//+build !effeinject

package main

import (
	"example.com/foo"
	"fmt"
)

func A(service AService) AFunc {
	return func() error {
		SuperStructVal3, err5 := service.Step1()
		if err5 != nil {
			return err5
		}
		err5 = func(SuperStructVal2 SuperStruct) error {
			switch SuperStructVal2.Foo {
			case true:
				err3 := func(SuperStructVal SuperStruct) error {
					err := service.Step2(SuperStructVal)
					if err != nil {
						return err
					}
					return nil
				}(SuperStructVal2)
				if err3 != nil {
					return err3
				}
				return nil
			case false:
				err4 := func() error {
					err2 := service.Step3()
					if err2 != nil {
						return err2
					}
					return nil
				}()
				if err4 != nil {
					return err4
				}
				return nil
			default:
				return fmt.Errorf("unsupported logic by SuperStructVal2.Foo")
			}
		}(SuperStructVal3)
		if err5 != nil {
			return err5
		}
		return nil
	}
}
func NewAImpl() *AImpl {
	return &AImpl{step1FieldFunc: step1(), step2FieldFunc: step2(), step3FieldFunc: step3()}
}

type AService interface {
	Step1() (SuperStruct, error)
	Step2(s SuperStruct) error
	Step3() error
}
type AImpl struct {
	step1FieldFunc func() (SuperStruct, error)
	step2FieldFunc func(s SuperStruct) error
	step3FieldFunc func() error
}
type AFunc func() error

func (a *AImpl) Step1() (SuperStruct, error) { return a.step1FieldFunc() }
func (a *AImpl) Step2(s SuperStruct) error   { return a.step2FieldFunc(s) }
func (a *AImpl) Step3() error                { return a.step3FieldFunc() }
